# HPC_matrix_multi_GPU
## Задание
2 лабораторная по высокопроизводительным вычислениям.

Задача: реализовать алгоритм сложения элементов вектора
Язык: C++ или Python
Входные данные: Вектор размером 1 000..1 000 000 значений.
Выходные данные: сумма элементов вектора + время вычисления
Реализация должна содержать 2 функции сложения элементов вектора: на CPU и на
GPU с применением CUDA.
Отчет о проделанной лабораторной работе - это git-репозиторий с исходным кодом
реализации + описание проделанной работы там же в readme.
Необходимо описать реализацию, объяснив, что конкретно было распараллелено и
почему.
Провести эксперименты: получить сумму векторов разных размеров (провести 5 или
более экспериментов), посчитать ускорение. Результаты привести в виде
таблицы/графика.

## Техническое обеспечение:
1) Графические процессоры, доступные в Colab, часто включают Nvidia K80s, T4s, P4s и P100s. Невозможно выбрать, к какому типу графического процессора вы можете подключиться в Colab в любой момент времени. 
2) Процессор Intel(R) Core(TM) i3-3110M CPU @ 2.40GHz   2.40 GHz
3) ОЗУ -  8,00 ГБ (доступно: 7,71 ГБ)
4) Система - Windows 10 (версия - 20H2) 
5) Язык реализации программы - Python 3.7.0

## Описание
Реализовано 2 функции: DeviceHost, dev_vec_sum.
Распараллеливание находится в dev_vec_sum, в строчке sum += a[idx]+b[idx]
На вход функцииям подается 1 разбитый на 2 части упорядоченный вектор с элементами от 0 и до N.
В данной программе не учитывается время копирывания массивов на видеокарту, так как этот шаг занимает слишком много времени.
## Таблица
<table border="0" cellpadding="0" cellspacing="0" id="sheet0" class="sheet0 gridlines">
<col class="col0">
<col class="col1">
<col class="col2">
<tbody>
<tr class="row0">
<td class="column0 style2 s">Shape</td>
<td class="column1 style1 s">CPU_time</td>
<td class="column3 style1 s">GPU_time</td>
</tr>
<tr class="row1">
<td class="column0 style1 n">1000</td>
<td class="column1 style3 n">0.000019</td>
<td class="column3 style3 n">0.000529</td>
</tr>
<tr class="row2">
<td class="column0 style1 n">10000</td>
<td class="column1 style3 n">0.000070</td>
<td class="column3 style3 n">0.000402</td>
</tr>
<tr class="row3">
<td class="column0 style1 n">100000</td>
<td class="column1 style3 n">0.000582</td>
<td class="column3 style3 n">0.000311</td>
</tr>
<tr class="row4">
<td class="column0 style1 n">1000000</td>
<td class="column1 style3 n">0.007611</td>
<td class="column3 style3 n">0.000874</td>
</tr>
<tr class="row5">
<td class="column0 style1 n">10000000</td>
<td class="column1 style3 n">0.071744</td>
<td class="column3 style3 n">0.000759</td>
</tbody>
</table>


## Вывод
Мы можем наблюдать, что размер входных данных не влияет на время параллельного вычисления, а вычисления на CPU становятся все дольше.
